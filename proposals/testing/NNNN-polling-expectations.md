# Polling Expectations

* Proposal: [ST-NNNN](NNNN-polling-expectations.md)
* Authors: [Rachel Brindle](https://github.com/younata)
* Review Manager: TBD
* Status: **Awaiting review**
* Implementation: [swiftlang/swift-testing#1115](https://github.com/swiftlang/swift-testing/pull/1115)
* Review: ([Pitch](https://forums.swift.org/t/pitch-polling-expectations/79866))

## Introduction

Test authors frequently need to wait for some background activity to complete
or reach an expected state before continuing. This proposal introduces a new API
to enable polling for an expected state.

## Motivation

Test authors can currently utilize the existing [`confirmation`](https://swiftpackageindex.com/swiftlang/swift-testing/main/documentation/testing/confirmation(_:expectedcount:isolation:sourcelocation:_:)-5mqz2)
APIs or awaiting on an `async` callable in order to block test execution until
a callback is called, or an async callable returns. However, this requires the
code being tested to support callbacks or return a status as an async callable.

This proposal adds another avenue for waiting for code to update to a specified
value, by proactively polling the test closure until it passes or a timeout is
reached.

More concretely, we can imagine a type that updates its status over an
indefinite timeframe:

```swift
actor Aquarium {
    var dolphins: [Dolphin]
    
    func raiseDolphins() async {
        // over a very long timeframe
        dolphins.append(Dolphin())
    }
}
```

## Proposed solution

This proposal introduces new members of the `confirmation` family of functions:
`confirmPassesEventually` and `confirmAlwaysPasses`. These functions take in
a closure to be continuously evaluated until the specific condition passes.

`confirmPassesEventually` will evaluate the closure until the first time it
returns true or a non-nil value. `confirmAlwaysPasses` will evaluate the
closure until it returns false or nil. If neither case happens, evaluation will
continue until the closure has been called some amount of times.

Tests will now be able to poll code updating in the background using
either of the new overloads:

```swift
let subject = Aquarium()
Task {
    await subject.raiseDolphins()
}
await confirmPassesEventually {
    subject.dolphins.count == 1
}
```

## Detailed design

### New confirmation functions

We will introduce 4 new members of the confirmation family of functions to the
testing library:

```swift
/// Confirm that some expression eventually returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, waiting on some state to change that cannot be easily confirmed
/// through other forms of `confirmation`.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmPassesEventually(
  _ comment: Comment? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async

/// Confirm that some expression eventually returns a non-nil value
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// - Returns: The first non-nil value returned by `body`.
///
/// - Throws: A `PollingFailedError` will be thrown if `body` never returns a
///   non-optional value
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, waiting on some state to change that cannot be easily confirmed
/// through other forms of `confirmation`.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmPassesEventually<R>(
  _ comment: Comment? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> R?
) async throws -> R where R: Sendable

/// Confirm that some expression always returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, confirming that some state does not change.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmAlwaysPasses(
  _ comment: Comment? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async

/// Confirm that some expression always returns a non-optional value
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// - Returns: The value from the last time `body` was invoked.
///
/// - Throws: A `PollingFailedError` will be thrown if `body` ever returns a
///   non-optional value
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, confirming that some state does not change.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmAlwaysPasses<R>(
  _ comment: Comment? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> R?
) async throws -> R where R: Sendable
```

### New Error Type

A new error type, `PollingFailedError` to be thrown when polling doesn't return
a non-nil value:

```swift
/// A type describing an error thrown when polling fails to return a non-nil
/// value
public struct PollingFailedError: Error {}
```

### New Issue Kind

A new Issue.Kind, `confirmationPollingFailed` will be added to represent the
case here confirmation polling fails. This issue kind will be recorded when
polling fails.

### Platform Availability

Polling expectations will not be available on platforms that do not support
Swift Concurrency.

### Usage

These functions can be used with an async test function:

```swift
@Test func `The aquarium's dolphin nursery works`() async {
    let subject = Aquarium()
    Task {
        await subject.raiseDolphins()
    }
    await confirmPassesEventually {
        await subject.dolphins.count == 1
    }
}
```

With the definition of `Aquarium` above, the closure will only need to be
evaluated a few times before it starts returning true. At which point polling
will end, and no failure will be reported.

Polling will be stopped in the following cases:

- After the expression has been evaluated 1 million times.
- If the task that started the polling is cancelled.
- For `confirmPassesEventually`: The first time the closure returns true or a
  non-nil value
- For `confirmAlwaysPasses`: The first time the closure returns false or nil.
- The first time the closure throws an error.

## Source compatibility

This is a new interface that is unlikely to collide with any existing
client-provided interfaces. The typical Swift disambiguation tools can be used
if needed.

## Future directions

We plan to add support for more push-based monitoring, such as integrating with
the Observation module to monitor changes to `@Observable` objects during some
lifetime.

## Alternatives considered

### Use timeouts

Polling could be written in such a way that it stops after some amount of time
has passed. Naively, this could be written as:

```swift
func poll(timeout: Duration, expression: () -> Bool) -> Bool {
    let clock: Clock = // ...
    let endTimestamp = clock.now + timeout
    while clock.now < endTimestamp {
        if expression() { return true }
    }
    return false
}
```

Unfortunately, while this could work reasonably well in an environment where
tests are executed serially, the concurrent test runner the testing library uses
means that timeouts are inherently unreliable. Importantly, timeouts become more
unreliable the more tests in the test suite.

### Use macros instead of functions

Instead of adding new bare functions, polling could be written as additional
macros, something like:

```swift
#expectUntil { ... }
#expectAlways { ... }
```

However, there's no additional benefit to doing this, and it may even lead test
authors to use polling when other mechanisms would be more appropriate.

### `confirmPassesEventually` continues to evaluate expression after passing

For `confirmPassesEventually`, we thought about requiring the expression
to continue to pass after it starts passing. The idea is to prevent test
flakiness caused by an expectation that initially passes, but stops passing as
a result of (intended) background activity. For example:

```swift
@Test func `The aquarium's dolphin nursery works`() async {
    let subject = Aquarium()
    await subject.raiseDolphins()
    Task {
        await subject.raiseDolphins()
    }
    await confirmPassesEventually {
        await subject.dolphins.count == 1
    }
}
```

This test is flaky, but will pass more often than not. However, it is still
incorrect. If we were to change `confirmPassesEventually` to instead check
that the expression continues to pass after the first time it succeeds until the
timeout is reached, then this test would correctly be flagged as failing each
time it's ran.

We chose to address this by using the name `confirmPassesEventually` instead of
changing the behavior. `confirmPassesEventually` makes it clear the exact
behavior that will happen: the expression will be evaluated until the first time
it passes, and no more. We hope that this will help test authors to better
recognize these situations.

## Acknowledgments

This proposal is heavily inspired by Nimble's [Polling Expectations](https://quick.github.io/Nimble/documentation/nimble/pollingexpectations/).
In particular, thanks to [Jeff Hui](https://github.com/jeffh) for writing the
original implementation of Nimble's Polling Expectations.
