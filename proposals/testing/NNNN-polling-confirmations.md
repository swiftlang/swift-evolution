# Polling Confirmations

* Proposal: [ST-NNNN](NNNN-polling-confirmations.md)
* Authors: [Rachel Brindle](https://github.com/younata)
* Review Manager: TBD
* Status: **Awaiting review**
* Implementation: [swiftlang/swift-testing#1115](https://github.com/swiftlang/swift-testing/pull/1115)
* Review: ([Pitch](https://forums.swift.org/t/pitch-polling-expectations/79866))

## Introduction

Test authors frequently need to wait for some background activity to complete
or reach an expected state before continuing. This proposal introduces a new API
to enable polling for an expected state.

## Motivation

Test authors can currently utilize the existing [`confirmation`](https://swiftpackageindex.com/swiftlang/swift-testing/main/documentation/testing/confirmation(_:expectedcount:isolation:sourcelocation:_:)-5mqz2)
APIs or awaiting on an `async` callable in order to block test execution until
a callback is called, or an async callable returns. However, this requires the
code being tested to support callbacks or return a status as an async callable.

This proposal adds another avenue for waiting for code to update to a specified
value, by proactively polling the test closure until it passes or a timeout is
reached.

More concretely, we can imagine a type that updates its status over an
indefinite timeframe:

```swift
actor Aquarium {
    var dolphins: [Dolphin]
    
    func raiseDolphins() async {
        // over a very long timeframe
        dolphins.append(Dolphin())
    }
}
```

## Proposed solution

This proposal introduces new members of the `confirmation` family of functions:
`confirmPassesEventually` and `confirmAlwaysPasses`. These functions take in
a closure to be repeatedly evaluated until the specific condition passes,
waiting at least some amount of time - specified by `pollingInterval` and
defaulting to 1 millisecond - before evaluating the closure again.

`confirmPassesEventually` will evaluate the closure until the first time it
returns true or a non-nil value. `confirmAlwaysPasses` will evaluate the
closure until it returns false or nil. If neither case happens, evaluation will
continue until the closure has been called some amount of times.

Tests will now be able to poll code updating in the background using
either of the new overloads:

```swift
let subject = Aquarium()
Task {
    await subject.raiseDolphins()
}
await confirmPassesEventually {
    subject.dolphins.count == 1
}
```

## Detailed design

### New confirmation functions

We will introduce 5 new members of the confirmation family of functions to the
testing library:

```swift
/// Confirm that some expression eventually returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or
///     suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or
///     suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, waiting on some state to change that cannot be easily confirmed
/// through other forms of `confirmation`.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmPassesEventually(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async

/// Require that some expression eventually returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or
///     suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// - Throws: A `PollingFailedError` will be thrown if the expression never
///   returns true.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, waiting on some state to change that cannot be easily confirmed
/// through other forms of `confirmation`.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func requirePassesEventually(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async throws

/// Confirm that some expression eventually returns a non-nil value
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or
///     suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// - Returns: The first non-nil value returned by `body`.
///
/// - Throws: A `PollingFailedError` will be thrown if `body` never returns a
///   non-optional value.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, waiting on some state to change that cannot be easily confirmed
/// through other forms of `confirmation`.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmPassesEventually<R>(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> R?
) async throws -> R where R: Sendable

/// Confirm that some expression always returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmAlwaysPassesConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmAlwaysPassesConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmAlwaysPassesConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmAlwaysPassesConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, confirming that some state does not change.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmAlwaysPasses(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async

/// Require that some expression always returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmAlwaysPassesConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmAlwaysPassesConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmAlwaysPassesConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmAlwaysPassesConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// - Throws: A `PollingFailedError` will be thrown if the expression ever
///   returns false.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, confirming that some state does not change.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func requireAlwaysPasses(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async throws
```

### New Error Type

A new error type, `PollingFailedError` to be thrown when polling doesn't return
a non-nil value:

```swift
/// A type describing an error thrown when polling fails.
public struct PollingFailedError: Error, Equatable {}
```

### New Issue Kind

A new Issue.Kind, `confirmationPollingFailed` will be added to represent the
case where a polling confirmation failed. This issue kind will be recorded when
`confirmPassesEventually` and `confirmAlwaysPasses` fail, but not when
`requirePassesEventually` or `requireAlwaysPasses` fail.

### New Traits

Two new traits will be added to change the default values for the
`maxPollingIterations` and `pollingInterval` arguments. Test authors often
want to poll for the `passesEventually` behavior more than they poll for the
`alwaysPasses` behavior, which is why there are separate traits for configuring
defaults for these functions.

```swift
/// A trait to provide a default polling configuration to all usages of
/// ``confirmPassesEventually`` within a test or suite.
///
/// To add this trait to a test, use the
/// ``Trait/confirmPassesEventuallyDefaults`` function.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public struct ConfirmPassesEventuallyConfigurationTrait: TestTrait, SuiteTrait {
  public var maxPollingIterations: Int?
  public var pollingInterval: Duration?

  public var isRecursive: Bool { true }

  public init(maxPollingIterations: Int?, pollingInterval: Duration?)
}

/// A trait to provide a default polling configuration to all usages of
/// ``confirmPassesAlways`` within a test or suite.
///
/// To add this trait to a test, use the ``Trait/confirmAlwaysPassesDefaults``
/// function.
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public struct ConfirmAlwaysPassesConfigurationTrait: TestTrait, SuiteTrait {
  public var maxPollingIterations: Int?
  public var pollingInterval: Duration?

  public var isRecursive: Bool { true }

  public init(maxPollingIterations: Int?, pollingInterval: Duration?)
}

@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
extension Trait where Self == ConfirmPassesEventuallyConfigurationTrait {
  /// Specifies defaults for ``confirmPassesEventually`` in the test or suite.
  ///
  /// - Parameters:
  ///   - maxPollingIterations: The maximum amount of times to attempt polling.
  ///     If nil, polling will be attempted up to 1000 times.
  ///     `maxPollingIterations` must be greater than 0.
  ///   - pollingInterval: The minimum amount of time to wait between polling
  ///     attempts.
  ///     If nil, polling will wait at least 1 millisecond between polling
  ///     attempts.
  ///     `pollingInterval` must be greater than 0.
  public static func confirmPassesEventuallyDefaults(
    maxPollingIterations: Int? = nil,
    pollingInterval: Duration? = nil
  ) -> Self
}

@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
extension Trait where Self == ConfirmPassesAlwaysConfigurationTrait {
  /// Specifies defaults for ``confirmAlwaysPasses`` in the test or suite.
  ///
  /// - Parameters:
  ///   - maxPollingIterations: The maximum amount of times to attempt polling.
  ///     If nil, polling will be attempted up to 1000 times.
  ///     `maxPollingIterations` must be greater than 0.
  ///   - pollingInterval: The minimum amount of time to wait between polling
  ///     attempts.
  ///     If nil, polling will wait at least 1 millisecond between polling
  ///     attempts.
  ///     `pollingInterval` must be greater than 0.
  public static func confirmAlwaysPassesDefaults(
    maxPollingIterations: Int? = nil,
    pollingInterval: Duration? = nil
  ) -> Self
}
```

Specifying `maxPollingIterations` or `pollingInterval` directly on either
`confirmPassesEventually` or `confirmAlwaysPasses` will override any value
provided by the trait.

### Default Polling Configuration

For both `confirmPassesEventually` and `confirmsAlwaysPasses`, the Testing
library will default `maxPollingIterations` to 1000, and `pollingInterval` to
1 millisecond. This allows for tests on lightly-loaded systems such as developer
workstations to run in a little over 1 second wall-clock time, while still
being able to gracefully handle running on large loads.

### Platform Availability

Polling confirmations will not be available on platforms that do not support
Swift Concurrency.

### Usage

These functions can be used with an async test function:

```swift
@Test func `The aquarium's dolphin nursery works`() async {
    let subject = Aquarium()
    Task {
        await subject.raiseDolphins()
    }
    await confirmPassesEventually {
        await subject.dolphins.count == 1
    }
}
```

With the definition of `Aquarium` above, the closure will only need to be
evaluated a few times before it starts returning true. At which point polling
will end, and no failure will be reported.

Polling will be stopped in the following cases:

- After the expression has been evaluated up to the count specified in
  `maxPollingInterations`.
- If the task that started the polling is cancelled.
- For `confirmPassesEventually`: The first time the closure returns true or a
  non-nil value
- For `confirmAlwaysPasses`: The first time the closure returns false or nil.
- The first time the closure throws an error.

## Source compatibility

This is a new interface that is unlikely to collide with any existing
client-provided interfaces. The typical Swift disambiguation tools can be used
if needed.

## Future directions

We plan to add support for more push-based monitoring, such as integrating with
the Observation module to monitor changes to `@Observable` objects during some
lifetime.

## Alternatives considered

### Use timeouts

Polling could be written in such a way that it stops after some amount of time
has passed. Naively, this could be written as:

```swift
func poll(timeout: Duration, expression: () -> Bool) -> Bool {
    let clock: Clock = // ...
    let endTimestamp = clock.now + timeout
    while clock.now < endTimestamp {
        if expression() { return true }
    }
    return false
}
```

Unfortunately, while this could work reasonably well in an environment where
tests are executed serially, the concurrent test runner the testing library uses
means that timeouts are inherently unreliable. Importantly, timeouts become more
unreliable the more tests in the test suite.

### Use only polling iterations

Another option considered was only using polling iterations. Naively, this
would write the main polling loop as:

```swift
func poll(iterations: Int, expression: () -> Bool) async -> Bool {
    for _ in 0..<iterations {
        if expression() { return true }
        Task.yield()
    }
    return false
}
```

However, while this works and is resistant to many of the issues timeouts face
in concurrent testing environments, it is extremely difficult for test authors
to predict a good-enough polling iterations value. It is much easier for a
human to predict that something should take a second or two than it is for a
human to predict how many polling intervals it should take before the state
changes - polling even a million times on a lightly-loaded system can finish in
well under a millisecond. Because of this, we decided to add on the polling
interval argument: a minimum duration to wait between polling, to make it much
easier for test authors to predict a good-enough guess for when to stop polling.

### Allow `pollingInterval` to be `.zero`

We could allow test authors to set `pollingInterval` as `Duration.zero`, making
polling behave as if only polling iterations is counted.
We chose not to allow this for the same reason we chose to add a wait between
polling: this makes it much easier for test authors to predict when to stop
polling.

### Use macros instead of functions

Instead of adding new bare functions, polling could be written as additional
macros, something like:

```swift
#expectUntil { ... }
#expectAlways { ... }
```

However, there's no additional benefit to doing this, and it may even lead test
authors to use polling when other mechanisms would be more appropriate.

### `confirmPassesEventually` continues to evaluate expression after passing

For `confirmPassesEventually`, we thought about requiring the expression
to continue to pass after it starts passing. The idea is to prevent test
flakiness caused by an expectation that initially passes, but stops passing as
a result of (intended) background activity. For example:

```swift
@Test func `The aquarium's dolphin nursery works`() async {
    let subject = Aquarium()
    await subject.raiseDolphins()
    Task {
        await subject.raiseDolphins()
    }
    await confirmPassesEventually {
        await subject.dolphins.count == 1
    }
}
```

This test is flaky, but will pass more often than not. However, it is still
incorrect. If we were to change `confirmPassesEventually` to instead check
that the expression continues to pass after the first time it succeeds until the
timeout is reached, then this test would correctly be flagged as failing each
time it's ran.

We chose to address this by using the name `confirmPassesEventually` instead of
changing the behavior. `confirmPassesEventually` makes it clear the exact
behavior that will happen: the expression will be evaluated until the first time
it passes, and no more. We hope that this will help test authors to better
recognize these situations.

## Acknowledgments

This proposal is heavily inspired by Nimble's [Polling Expectations](https://quick.github.io/Nimble/documentation/nimble/pollingexpectations/).
In particular, thanks to [Jeff Hui](https://github.com/jeffh) for writing the
original implementation of Nimble's Polling Expectations.
